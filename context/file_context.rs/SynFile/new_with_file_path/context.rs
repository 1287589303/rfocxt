# [derive (Debug , Clone)] pub struct SynFile { pub file_name : String , pub file_path : PathBuf , pub consts : Vec < ConstItem > , pub foreign_mods : Vec < ForeignModItem > , pub macros : Vec < MacroItem > , pub trait_aliases : Vec < TraitAliasItem > , pub uses : Vec < UseItem > , pub mods : Vec < ModItem > , pub statics : Vec < StaticItem > , pub types : Vec < TypeItem > , pub structs : Vec < StructItem > , pub enums : Vec < EnumItem > , pub unions : Vec < UnionItem > , pub functions : Vec < FunctionItem > , pub traits : Vec < TraitItem > , } impl SynFile { pub fn new () -> Self { SynFile { file_name : String :: new () , file_path : PathBuf :: new () , consts : Vec :: new () , foreign_mods : Vec :: new () , macros : Vec :: new () , trait_aliases : Vec :: new () , uses : Vec :: new () , mods : Vec :: new () , statics : Vec :: new () , types : Vec :: new () , structs : Vec :: new () , enums : Vec :: new () , unions : Vec :: new () , functions : Vec :: new () , traits : Vec :: new () , } } pub fn new_with_file_path (file_path : PathBuf) -> Self { let mut syn_file = SynFile :: new () ; syn_file . file_path = file_path . clone () ; syn_file . file_name = file_path . clone () . file_name () . unwrap () . to_string_lossy () . to_string () ; syn_file } pub fn from_syntax (file_path : PathBuf , syntax : & File) -> Self { let mut syn_file = SynFile :: new_with_file_path (file_path) ; for item in syntax . items . clone () { match item { Item :: Const (item_const) => { let mut const_item = ConstItem :: new () ; const_item . item = Some (item_const) ; syn_file . consts . push (const_item) ; } Item :: ForeignMod (item_foreign_mod) => { let mut foreign_mod_item = ForeignModItem :: new () ; foreign_mod_item . item = Some (item_foreign_mod) ; syn_file . foreign_mods . push (foreign_mod_item) ; } Item :: Macro (item_macro) => { let mut macro_item = MacroItem :: new () ; macro_item . item = Some (item_macro) ; syn_file . macros . push (macro_item) ; } Item :: TraitAlias (item_trait_alias) => { let mut trait_alias_item = TraitAliasItem :: new () ; trait_alias_item . item = Some (item_trait_alias) ; syn_file . trait_aliases . push (trait_alias_item) ; } Item :: Use (item_use) => { let mut use_item = UseItem :: new () ; use_item . item = Some (item_use) ; syn_file . uses . push (use_item) ; } Item :: Mod (item_mod) => { let mut mod_item = ModItem :: new () ; mod_item . item = Some (item_mod . clone ()) ; syn_file . mods . push (mod_item) ; } Item :: Static (item_static) => { let mut static_item = StaticItem :: new () ; static_item . item = Some (item_static) ; syn_file . statics . push (static_item) ; } Item :: Type (item_type) => { let mut type_item = TypeItem :: new () ; type_item . item = Some (item_type) ; syn_file . types . push (type_item) ; } Item :: Struct (item_struct) => { let mut struct_item = StructItem :: new () ; let struct_name = item_struct . ident . to_string () ; struct_item . struct_name = struct_name ; struct_item . item = Some (item_struct) ; syn_file . structs . push (struct_item) ; } Item :: Enum (item_enum) => { let mut enum_item = EnumItem :: new () ; let enum_name = item_enum . ident . to_string () ; enum_item . enum_name = enum_name ; enum_item . item = Some (item_enum) ; syn_file . enums . push (enum_item) ; } Item :: Union (item_union) => { let mut union_item = UnionItem :: new () ; let union_name = item_union . ident . to_string () ; union_item . union_name = union_name ; union_item . item = Some (item_union) ; syn_file . unions . push (union_item) ; } Item :: Impl (item_impl) => { let mut impl_item = ImplItem :: new () ; let mut empty_item_impl = item_impl . clone () ; empty_item_impl . items = Vec :: new () ; impl_item . item = Some (empty_item_impl) ; for item in item_impl . items . iter () { match item { SynImplItem :: Const (const_item) => { impl_item . consts . push (const_item . clone ()) ; } SynImplItem :: Type (type_item) => { impl_item . types . push (type_item . clone ()) ; } SynImplItem :: Fn (fn_item) => { let mut function_item = FunctionItem :: new () ; function_item . function_name = fn_item . sig . ident . to_string () ; function_item . item = Some (MyItemFn :: ImplFn (fn_item . clone ())) ; function_item . applications = visit_stmts (fn_item . block . stmts . clone ()) ; impl_item . functions . push (function_item) ; } _ => { } } } let mut name = String :: new () ; let ty = * item_impl . self_ty ; if let Type :: Path (ty_path) = ty { name = ty_path . path . segments . last () . unwrap () . ident . to_string () ; } let mut trait_name = String :: new () ; if item_impl . trait_ . clone () != None { trait_name = item_impl . trait_ . unwrap () . 1 . segments . last () . unwrap () . ident . to_string () ; } if trait_name == String :: new () { let mut b : bool = false ; for struct_item in syn_file . structs . iter_mut () { if struct_item . struct_name == name { struct_item . impls . push (impl_item . clone ()) ; b = true ; break ; } } if b == false { for enum_item in syn_file . enums . iter_mut () { if enum_item . enum_name == name { enum_item . impls . push (impl_item . clone ()) ; b = true ; break ; } } } if b == false { for union_item in syn_file . unions . iter_mut () { if union_item . union_name == name { union_item . impls . push (impl_item . clone ()) ; break ; } } } } else { let mut b : bool = false ; for struct_item in syn_file . structs . iter_mut () { if struct_item . struct_name == name { struct_item . traits . push (trait_name . clone ()) ; struct_item . traits_impls . push (impl_item . clone ()) ; b = true ; break ; } } if b == false { for enum_item in syn_file . enums . iter_mut () { if enum_item . enum_name == name { enum_item . traits . push (trait_name . clone ()) ; enum_item . traits_impls . push (impl_item . clone ()) ; b = true ; break ; } } } if b == false { for union_item in syn_file . unions . iter_mut () { if union_item . union_name == name { union_item . traits . push (trait_name . clone ()) ; union_item . traits_impls . push (impl_item . clone ()) ; break ; } } } } } Item :: Fn (item_fn) => { let mut function_item = FunctionItem :: new () ; let function_name : String = item_fn . sig . ident . to_string () ; function_item . function_name = function_name ; function_item . item = Some (MyItemFn :: Fn (item_fn . clone ())) ; function_item . applications = visit_stmts (item_fn . block . stmts . clone ()) ; syn_file . functions . push (function_item) ; } Item :: Trait (item_trait) => { let mut trait_item = TraitItem :: new () ; let trait_name : String = item_trait . ident . to_string () ; trait_item . trait_name = trait_name ; let mut empty_item_trait = item_trait . clone () ; empty_item_trait . items = Vec :: new () ; trait_item . item = Some (empty_item_trait) ; for item in item_trait . items . iter () { match item { SynTraitItem :: Const (const_item) => { trait_item . consts . push (const_item . clone ()) ; } SynTraitItem :: Type (type_item) => { trait_item . types . push (type_item . clone ()) ; } SynTraitItem :: Fn (fn_item) => { let mut function_item = FunctionItem :: new () ; function_item . function_name = fn_item . sig . ident . to_string () ; function_item . item = Some (MyItemFn :: TraitFn (fn_item . clone ())) ; if let Some (block) = & fn_item . default { function_item . applications = visit_stmts (block . stmts . clone ()) ; } trait_item . functions . push (function_item) ; } _ => { } } } syn_file . traits . push (trait_item) ; } _ => { } } } syn_file } pub fn change_applications (& mut self , all_names : & Vec < String >) { for function_item in self . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; } for struct_item in self . structs . iter_mut () { for impl_item in struct_item . impls . iter_mut () { for function_item in impl_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; function_item . applications . extend (struct_item . traits . iter () . map (| trait_name | trait_name . clone ()) ,) ; } } for trait_impl_item in struct_item . traits_impls . iter_mut () { for function_item in trait_impl_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; function_item . applications . extend (struct_item . traits . iter () . map (| trait_name | trait_name . clone ()) ,) ; } } } for enum_item in self . enums . iter_mut () { for impl_item in enum_item . impls . iter_mut () { for function_item in impl_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; function_item . applications . extend (enum_item . traits . iter () . map (| trait_name | trait_name . clone ())) ; } } for trait_impl_item in enum_item . traits_impls . iter_mut () { for function_item in trait_impl_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; function_item . applications . extend (enum_item . traits . iter () . map (| trait_name | trait_name . clone ())) ; } } } for union_item in self . unions . iter_mut () { for impl_item in union_item . impls . iter_mut () { for function_item in impl_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; function_item . applications . extend (union_item . traits . iter () . map (| trait_name | trait_name . clone ()) ,) ; } } for trait_impl_item in union_item . traits_impls . iter_mut () { for function_item in trait_impl_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; function_item . applications . extend (union_item . traits . iter () . map (| trait_name | trait_name . clone ()) ,) ; } } } for trait_item in self . traits . iter_mut () { for function_item in trait_item . functions . iter_mut () { function_item . applications . retain (| application | all_names . contains (application)) ; } } } pub fn to_string (& self) -> String { let mut items : Vec < Item > = Vec :: new () ; items . extend (self . types . iter () . map (| type_item | Item :: Type (type_item . item . clone () . unwrap ())) ,) ; items . extend (self . uses . iter () . map (| use_item | Item :: Use (use_item . item . clone () . unwrap ())) ,) ; items . extend (self . mods . iter () . map (| mod_item | Item :: Mod (mod_item . item . clone () . unwrap ())) ,) ; items . extend (self . foreign_mods . iter () . map (| foreign_mod_item | Item :: ForeignMod (foreign_mod_item . item . clone () . unwrap ())) ,) ; items . extend (self . macros . iter () . map (| macro_item | Item :: Macro (macro_item . item . clone () . unwrap ())) ,) ; items . extend (self . statics . iter () . map (| static_item | Item :: Static (static_item . item . clone () . unwrap ())) ,) ; items . extend (self . consts . iter () . map (| const_item | Item :: Const (const_item . item . clone () . unwrap ())) ,) ; items . extend (self . trait_aliases . iter () . map (| trait_alias_item | Item :: TraitAlias (trait_alias_item . item . clone () . unwrap ())) ,) ; items . extend (self . traits . iter () . map (| trait_item | trait_item . to_item_trait ()) ,) ; for struct_item in & self . structs { items . push (Item :: Struct (struct_item . item . clone () . unwrap ())) ; items . extend (struct_item . impls . iter () . map (| impl_item | impl_item . to_item_impl ()) ,) ; items . extend (struct_item . traits_impls . iter () . map (| trait_impl_item | trait_impl_item . to_item_impl ()) ,) ; } for enum_item in & self . enums { items . push (Item :: Enum (enum_item . item . clone () . unwrap ())) ; items . extend (enum_item . impls . iter () . map (| impl_item | impl_item . to_item_impl ()) ,) ; items . extend (enum_item . traits_impls . iter () . map (| trait_impl_item | trait_impl_item . to_item_impl ()) ,) ; } for union_item in & self . unions { items . push (Item :: Union (union_item . item . clone () . unwrap ())) ; items . extend (union_item . impls . iter () . map (| impl_item | impl_item . to_item_impl ()) ,) ; items . extend (union_item . traits_impls . iter () . map (| trait_impl_item | trait_impl_item . to_item_impl ()) ,) ; } let mut functions : Vec < ItemFn > = Vec :: new () ; for function in self . functions . iter () { if let MyItemFn :: Fn (item_fn) = function . item . clone () . unwrap () { functions . push (item_fn) ; } } items . extend (functions . iter () . map (| function_item | Item :: Fn (function_item . clone ())) ,) ; let tokens = quote ! { # (# items) * } ; tokens . to_string () } }