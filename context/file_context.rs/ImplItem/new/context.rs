# [derive (Debug , Clone)] pub struct ImplItem { pub item : Option < ItemImpl > , pub types : Vec < ImplItemType > , pub consts : Vec < ImplItemConst > , pub functions : Vec < FunctionItem > , } impl ImplItem { fn new () -> Self { ImplItem { item : None , types : Vec :: new () , consts : Vec :: new () , functions : Vec :: new () , } } fn to_item_impl (& self) -> Item { let mut item_impl = self . item . clone () . unwrap () ; item_impl . items . extend (self . types . iter () . map (| type_item | SynImplItem :: Type (type_item . clone ())) ,) ; item_impl . items . extend (self . consts . iter () . map (| const_impl | SynImplItem :: Const (const_impl . clone ())) ,) ; let mut functions : Vec < SynImplItem > = Vec :: new () ; for function in self . functions . iter () { if let MyItemFn :: ImplFn (item_function) = function . item . clone () . unwrap () { functions . push (SynImplItem :: Fn (item_function)) ; } } item_impl . items . extend (functions) ; Item :: Impl (item_impl) } }