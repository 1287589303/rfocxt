# [derive (Debug , Clone)] pub struct TraitItem { trait_name : String , item : Option < ItemTrait > , types : Vec < TraitItemType > , consts : Vec < TraitItemConst > , functions : Vec < FunctionItem > , } impl TraitItem { fn new () -> Self { TraitItem { trait_name : String :: new () , item : None , types : Vec :: new () , consts : Vec :: new () , functions : Vec :: new () , } } fn to_item_trait (& self) -> Item { let mut item_impl = self . item . clone () . unwrap () ; item_impl . items . extend (self . types . iter () . map (| type_item | SynTraitItem :: Type (type_item . clone ())) ,) ; item_impl . items . extend (self . consts . iter () . map (| const_impl | SynTraitItem :: Const (const_impl . clone ())) ,) ; let mut functions : Vec < SynTraitItem > = Vec :: new () ; for function in self . functions . iter () { if let MyItemFn :: TraitFn (item_function) = function . item . clone () . unwrap () { functions . push (SynTraitItem :: Fn (item_function)) ; } } item_impl . items . extend (functions) ; Item :: Trait (item_impl) } fn get_applications (& self) -> Vec < String > { let mut applications : Vec < String > = Vec :: new () ; for function_item in self . functions . iter () { applications . extend (function_item . applications . clone ()) ; } applications } } # [derive (Debug , Clone)] enum MyItemFn { Fn (ItemFn) , ImplFn (ImplItemFn) , TraitFn (TraitItemFn) , }